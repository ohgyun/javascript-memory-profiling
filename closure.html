<!doctype html5>
<html>
<head>
<meta charset="utf-8">
<title>Heap Profiling Test</title>
<style>
body {font-family:sans-serif;}
button {display:block; margin:10px; padding:10px; font-size:15px;}
</style>
</head>
<body>
<h1>Heap Profiling Test</h1>
<h2>클로저와 메모리</h2>
<p>버튼 클릭 전/후의 힙 스냅샷을 비교한다. 스냅샷에서 closure 속성을 확인한다.<br>
setTimeout과 클로저는 힙 할당 타임라인에서 보면 쉽게 이해할 수 있다.</p>
<button id="btnA" onclick="createLeakableEventListener();">DOM의 이벤트 핸들러와 클로저 (A)</button>
<button onclick="removeButtonA();">(A) 버튼을 문서에서 삭제</button>
<button id="btnB" onclick="createStableEventListener();">메모리 처리가 잘 된 핸들러 (B)</button>
<button id="release">(B) 버튼의 메모리 해제</button>
<button onclick="createTemporaryClosure();">setTimeout과 클로저</button>

<script>

function createBigString() {
    return new Array(10000).join('XXXXXXXXX');
}


// DOM에 이벤트 리스너를 추가할 때, 함수 종료 후에도 GC되지 않는다.
function createLeakableEventListener() {
    var button = document.getElementById('btnA');
    var bigString = createBigString();
    var bigStringNotUsed = createBigString();

    button.onclick = function onButton_A_Click() {
        // 클로저로 button과 bigString을 참조하고 있다.
        // 함수가 종료된 이후에도 bigString은 GC되지 않는다.
        // 함수 내에서 참조하고 있는 bigStringNotUsed에 대한 메모리는 할당되지 않는다.
        buttuon;
        console.log(bigString);
    };
}

// Button A를 문서에서 삭제한다.
// 하지만 클로저로 할당한 이벤트 핸들러는 삭제되지 않는다.
// onButton_A_Click 함수 내에서 button 객체를 직접적으로 사용하고 있진 않지만,
// 클로저 내의 context로 button 객체를 가지고 있기 때문이다.
function removeButtonA() {
    document.body.removeChild(document.getElementById('btnA'));
}


// 이벤트 핸들러에서 클로저로 데이터를 사용했다면 널 처리해준다. (1회성 데이터에 한함)
function createStableEventListener() {
    var button = document.getElementById('release');
    var temporaryBigString = createBigString();
    button.onclick = function onButton_B_Click() {
        console.log(temporaryBigString);
        // 1회성 핸들러였다면 null 처리해서 GC되도록 한다.
        button.onclick = null;
    };
}


function createTemporaryClosure() {
    var bigString = createBigString();
    setTimeout(function () {
        // 부모 함수는 종료되었지만, 클로저로 bigString에 대한 참조를 가지고 있다.
        // 이 함수가 종료되면 bigString에 대한 것도 GC된다.
        bigString;

        // 만약 여기서 bigString을 참조하고 있지 않다면 메모리가 할당되지 않는다.
        // 즉, 부모 함수 안에 자식 함수를 정의한다고 해서, 클로저로 부모의 모든 변수를 갖는 것은 아니다.
    }, 3000);
}

</script>
</body>
</html>