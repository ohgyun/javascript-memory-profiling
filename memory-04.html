<!doctype html5>
<html>
<head>
<meta charset="utf-8">
<title>Heap Profiling Test</title>
<style>
body {font-family:sans-serif;}
button {display:block; margin:10px; padding:10px; font-size:15px;}
</style>
</head>
<body>
<h1>Heap Profiling Test</h1>
<h2>클로저와 메모리</h2>
<p>타임라인이나 프로파일 패널에서 메모리 누수를 확인한다.</p>
<button onclick="createTemporaryClosure();">setTimeout과 클로저</button>
<button onclick="createLeakableEventListener();">DOM의 이벤트 핸들러와 클로저</button>
<button onclick="createStableEventListener();">메모리 처리가 잘 된 핸들러</button>
<button id="release">메모리 해제</button>
<script>

function createBigString() {
    return new Array(10000).join('XXXXXXXXX');
}

function createTemporaryClosure() {
    var bigString = createBigString();
    setTimeout(function () {
        // 부모 함수는 종료되었지만, 클로저로 bigString에 대한 참조를 가지고 있다.
        // 이 함수가 종료되면 bigString에 대한 것도 GC된다.
        bigString;

        // 만약 여기서 bigString을 참조하고 있지 않다면 메모리가 할당되지 않는다.
        // 즉, 부모 함수 안에 자식 함수를 정의한다고 해서, 클로저로 부모의 모든 변수를 갖는 것은 아니다.
    }, 3000);
}

// DOM에 이벤트 리스너를 추가할 때, 함수 종료 후에도 GC되지 않는다.
function createLeakableEventListener() {
    var button = document.getElementById('release');
    var temporaryBigString = createBigString();
    button.onclick = function () {
        // 클로저로 temporaryBigString을 참조하고 있다. 
        // 함수가 종료된 이후에도 temporaryBigString GC되지 않는다.
        console.log(temporaryBigString);
    };
}

// 이벤트 핸들러에서 클로저로 데이터를 사용했다면 널 처리해준다. (1회성 데이터에 한함)
function createStableEventListener() {
    var button = document.getElementById('release');
    var temporaryBigString = createBigString();
    button.onclick = function () {
        console.log(temporaryBigString);
        // 1회성 핸들러였다면 null 처리해서 GC되도록 한다.
        button.onclick = null;
    };
}

</script>
</body>
</html>